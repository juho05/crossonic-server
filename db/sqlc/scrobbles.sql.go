// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: scrobbles.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createScrobble = `-- name: CreateScrobble :one
INSERT INTO scrobbles
(user_name,song_id,album_id,time,song_duration_ms,duration_ms,submitted_to_listenbrainz,now_playing)
VALUES
($1,$2,$3,$4,$5,$6,$7,$8)
RETURNING user_name, song_id, album_id, time, song_duration_ms, duration_ms, submitted_to_listenbrainz, now_playing
`

type CreateScrobbleParams struct {
	UserName                string
	SongID                  string
	AlbumID                 *string
	Time                    pgtype.Timestamptz
	SongDurationMs          int32
	DurationMs              *int32
	SubmittedToListenbrainz bool
	NowPlaying              bool
}

func (q *Queries) CreateScrobble(ctx context.Context, arg CreateScrobbleParams) (*Scrobble, error) {
	row := q.db.QueryRow(ctx, createScrobble,
		arg.UserName,
		arg.SongID,
		arg.AlbumID,
		arg.Time,
		arg.SongDurationMs,
		arg.DurationMs,
		arg.SubmittedToListenbrainz,
		arg.NowPlaying,
	)
	var i Scrobble
	err := row.Scan(
		&i.UserName,
		&i.SongID,
		&i.AlbumID,
		&i.Time,
		&i.SongDurationMs,
		&i.DurationMs,
		&i.SubmittedToListenbrainz,
		&i.NowPlaying,
	)
	return &i, err
}

const deleteNowPlaying = `-- name: DeleteNowPlaying :exec
DELETE FROM scrobbles WHERE now_playing = true AND (user_name = $1 OR EXTRACT(EPOCH FROM (NOW() - time))*1000 > song_duration_ms*3)
`

func (q *Queries) DeleteNowPlaying(ctx context.Context, userName string) error {
	_, err := q.db.Exec(ctx, deleteNowPlaying, userName)
	return err
}

const getNowPlaying = `-- name: GetNowPlaying :one
SELECT user_name, song_id, album_id, time, song_duration_ms, duration_ms, submitted_to_listenbrainz, now_playing FROM scrobbles WHERE user_name = $1 AND now_playing = true AND EXTRACT(EPOCH FROM (NOW() - time))*1000 < song_duration_ms*3
`

func (q *Queries) GetNowPlaying(ctx context.Context, userName string) (*Scrobble, error) {
	row := q.db.QueryRow(ctx, getNowPlaying, userName)
	var i Scrobble
	err := row.Scan(
		&i.UserName,
		&i.SongID,
		&i.AlbumID,
		&i.Time,
		&i.SongDurationMs,
		&i.DurationMs,
		&i.SubmittedToListenbrainz,
		&i.NowPlaying,
	)
	return &i, err
}

const getNowPlayingSongs = `-- name: GetNowPlayingSongs :many
SELECT scrobbles.user_name, scrobbles.time, songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name, albums.replay_gain as album_replay_gain, albums.replay_gain_peak as album_replay_gain_peak, song_stars.created as starred, song_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM songs
JOIN scrobbles ON scrobbles.song_id = songs.id
LEFT JOIN albums ON albums.id = songs.album_id
LEFT JOIN song_stars ON song_stars.song_id = songs.id AND song_stars.user_name = $1
LEFT JOIN (
  SELECT song_id, AVG(song_ratings.rating) AS rating FROM song_ratings GROUP BY song_id
) avgr ON avgr.song_id = songs.id
LEFT JOIN song_ratings ON song_ratings.song_id = songs.id AND song_ratings.user_name = $1
WHERE scrobbles.now_playing = true AND EXTRACT(EPOCH FROM (NOW() - time))*1000 < scrobbles.song_duration_ms*3
ORDER BY scrobbles.time DESC
`

type GetNowPlayingSongsRow struct {
	UserName            string
	Time                pgtype.Timestamptz
	ID                  string
	Path                string
	AlbumID             *string
	Title               string
	Track               *int32
	Year                *int32
	Size                int64
	ContentType         string
	DurationMs          int32
	BitRate             int32
	SamplingRate        int32
	ChannelCount        int32
	DiscNumber          *int32
	Created             pgtype.Timestamptz
	Updated             pgtype.Timestamptz
	Bpm                 *int32
	MusicBrainzID       *string
	ReplayGain          *float32
	ReplayGainPeak      *float32
	Lyrics              *string
	CoverID             *string
	AlbumName           *string
	AlbumReplayGain     *float32
	AlbumReplayGainPeak *float32
	Starred             pgtype.Timestamptz
	UserRating          *int32
	AvgRating           float64
}

func (q *Queries) GetNowPlayingSongs(ctx context.Context, userName string) ([]*GetNowPlayingSongsRow, error) {
	rows, err := q.db.Query(ctx, getNowPlayingSongs, userName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNowPlayingSongsRow
	for rows.Next() {
		var i GetNowPlayingSongsRow
		if err := rows.Scan(
			&i.UserName,
			&i.Time,
			&i.ID,
			&i.Path,
			&i.AlbumID,
			&i.Title,
			&i.Track,
			&i.Year,
			&i.Size,
			&i.ContentType,
			&i.DurationMs,
			&i.BitRate,
			&i.SamplingRate,
			&i.ChannelCount,
			&i.DiscNumber,
			&i.Created,
			&i.Updated,
			&i.Bpm,
			&i.MusicBrainzID,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.Lyrics,
			&i.CoverID,
			&i.AlbumName,
			&i.AlbumReplayGain,
			&i.AlbumReplayGainPeak,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
