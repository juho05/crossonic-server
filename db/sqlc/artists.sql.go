// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: artists.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createArtist = `-- name: CreateArtist :one
INSERT INTO artists
(id, name, created, updated, music_brainz_id)
VALUES ($1, $2, NOW(), NOW(), $3)
RETURNING id, name, created, updated, music_brainz_id
`

type CreateArtistParams struct {
	ID            string
	Name          string
	MusicBrainzID *string
}

func (q *Queries) CreateArtist(ctx context.Context, arg CreateArtistParams) (*Artist, error) {
	row := q.db.QueryRow(ctx, createArtist, arg.ID, arg.Name, arg.MusicBrainzID)
	var i Artist
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Created,
		&i.Updated,
		&i.MusicBrainzID,
	)
	return &i, err
}

const deleteArtistsLastUpdatedBefore = `-- name: DeleteArtistsLastUpdatedBefore :exec
DELETE FROM artists WHERE updated < $1
`

func (q *Queries) DeleteArtistsLastUpdatedBefore(ctx context.Context, updated pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteArtistsLastUpdatedBefore, updated)
	return err
}

const findAlbumArtistRefsBySongs = `-- name: FindAlbumArtistRefsBySongs :many
SELECT songs.id as song_id, artists.id, artists.name FROM songs
JOIN albums ON songs.album_id = albums.id
JOIN album_artist ON album_artist.album_id = albums.id
JOIN artists ON album_artist.artist_id = artists.id
WHERE songs.id = any($1::text[])
`

type FindAlbumArtistRefsBySongsRow struct {
	SongID string
	ID     string
	Name   string
}

func (q *Queries) FindAlbumArtistRefsBySongs(ctx context.Context, songIds []string) ([]*FindAlbumArtistRefsBySongsRow, error) {
	rows, err := q.db.Query(ctx, findAlbumArtistRefsBySongs, songIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAlbumArtistRefsBySongsRow
	for rows.Next() {
		var i FindAlbumArtistRefsBySongsRow
		if err := rows.Scan(&i.SongID, &i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findArtist = `-- name: FindArtist :one
SELECT artists.id, artists.name, artists.created, artists.updated, artists.music_brainz_id, artist_stars.created as starred, artist_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM artists
LEFT JOIN artist_stars ON artist_stars.artist_id = artists.id AND artist_stars.user_name = $1
LEFT JOIN (
  SELECT artist_id, AVG(artist_ratings.rating) AS rating FROM artist_ratings GROUP BY artist_id
) avgr ON avgr.artist_id = artists.id
LEFT JOIN artist_ratings ON artist_ratings.artist_id = artists.id AND artist_ratings.user_name = $1
WHERE artists.id = $2
`

type FindArtistParams struct {
	UserName string
	ID       string
}

type FindArtistRow struct {
	ID            string
	Name          string
	Created       pgtype.Timestamptz
	Updated       pgtype.Timestamptz
	MusicBrainzID *string
	Starred       pgtype.Timestamptz
	UserRating    *int32
	AvgRating     float64
}

func (q *Queries) FindArtist(ctx context.Context, arg FindArtistParams) (*FindArtistRow, error) {
	row := q.db.QueryRow(ctx, findArtist, arg.UserName, arg.ID)
	var i FindArtistRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Created,
		&i.Updated,
		&i.MusicBrainzID,
		&i.Starred,
		&i.UserRating,
		&i.AvgRating,
	)
	return &i, err
}

const findArtistRefsByAlbums = `-- name: FindArtistRefsByAlbums :many
SELECT album_artist.album_id, artists.id, artists.name FROM album_artist
JOIN artists ON album_artist.artist_id = artists.id
WHERE album_artist.album_id = any($1::text[])
`

type FindArtistRefsByAlbumsRow struct {
	AlbumID string
	ID      string
	Name    string
}

func (q *Queries) FindArtistRefsByAlbums(ctx context.Context, albumIds []string) ([]*FindArtistRefsByAlbumsRow, error) {
	rows, err := q.db.Query(ctx, findArtistRefsByAlbums, albumIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindArtistRefsByAlbumsRow
	for rows.Next() {
		var i FindArtistRefsByAlbumsRow
		if err := rows.Scan(&i.AlbumID, &i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findArtistRefsBySongs = `-- name: FindArtistRefsBySongs :many
SELECT song_artist.song_id, artists.id, artists.name, artists.music_brainz_id FROM song_artist
JOIN artists ON song_artist.artist_id = artists.id
WHERE song_artist.song_id = any($1::text[])
`

type FindArtistRefsBySongsRow struct {
	SongID        string
	ID            string
	Name          string
	MusicBrainzID *string
}

func (q *Queries) FindArtistRefsBySongs(ctx context.Context, songIds []string) ([]*FindArtistRefsBySongsRow, error) {
	rows, err := q.db.Query(ctx, findArtistRefsBySongs, songIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindArtistRefsBySongsRow
	for rows.Next() {
		var i FindArtistRefsBySongsRow
		if err := rows.Scan(
			&i.SongID,
			&i.ID,
			&i.Name,
			&i.MusicBrainzID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findArtistSimple = `-- name: FindArtistSimple :one
SELECT id, name, created, updated, music_brainz_id FROM artists WHERE id = $1
`

func (q *Queries) FindArtistSimple(ctx context.Context, id string) (*Artist, error) {
	row := q.db.QueryRow(ctx, findArtistSimple, id)
	var i Artist
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Created,
		&i.Updated,
		&i.MusicBrainzID,
	)
	return &i, err
}

const findArtists = `-- name: FindArtists :many
SELECT artists.id, artists.name, artists.created, artists.updated, artists.music_brainz_id, COALESCE(aa.count, 0) AS album_count, artist_stars.created as starred, artist_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM artists
LEFT JOIN (
  SELECT artist_id, COUNT(*) AS count FROM album_artist GROUP BY artist_id
) aa ON aa.artist_id = artists.id
LEFT JOIN artist_stars ON artist_stars.artist_id = artists.id AND artist_stars.user_name = $1
LEFT JOIN (
  SELECT artist_id, AVG(artist_ratings.rating) AS rating FROM artist_ratings GROUP BY artist_id
) avgr ON avgr.artist_id = artists.id
LEFT JOIN artist_ratings ON artist_ratings.artist_id = artists.id AND artist_ratings.user_name = $1
ORDER BY lower(artists.name)
`

type FindArtistsRow struct {
	ID            string
	Name          string
	Created       pgtype.Timestamptz
	Updated       pgtype.Timestamptz
	MusicBrainzID *string
	AlbumCount    int64
	Starred       pgtype.Timestamptz
	UserRating    *int32
	AvgRating     float64
}

func (q *Queries) FindArtists(ctx context.Context, userName string) ([]*FindArtistsRow, error) {
	rows, err := q.db.Query(ctx, findArtists, userName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindArtistsRow
	for rows.Next() {
		var i FindArtistsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Updated,
			&i.MusicBrainzID,
			&i.AlbumCount,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findArtistsByName = `-- name: FindArtistsByName :many
SELECT id, name, created, updated, music_brainz_id FROM artists WHERE name = any($1::text[])
`

func (q *Queries) FindArtistsByName(ctx context.Context, artistNames []string) ([]*Artist, error) {
	rows, err := q.db.Query(ctx, findArtistsByName, artistNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Artist
	for rows.Next() {
		var i Artist
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Updated,
			&i.MusicBrainzID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchArtists = `-- name: SearchArtists :many
SELECT artists.id, artists.name, artists.created, artists.updated, artists.music_brainz_id, COALESCE(aa.count, 0) AS album_count, artist_stars.created as starred, artist_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM artists
LEFT JOIN (
  SELECT artist_id, COUNT(*) AS count FROM album_artist GROUP BY artist_id
) aa ON aa.artist_id = artists.id
LEFT JOIN artist_stars ON artist_stars.artist_id = artists.id AND artist_stars.user_name = $1
LEFT JOIN (
  SELECT artist_id, AVG(artist_ratings.rating) AS rating FROM artist_ratings GROUP BY artist_id
) avgr ON avgr.artist_id = artists.id
LEFT JOIN artist_ratings ON artist_ratings.artist_id = artists.id AND artist_ratings.user_name = $1
WHERE position(lower($4) in lower(artists.name)) > 0
ORDER BY position(lower($4) in lower(artists.name)), lower(artists.name)
OFFSET $2 LIMIT $3
`

type SearchArtistsParams struct {
	UserName  string
	Offset    int32
	Limit     int32
	SearchStr string
}

type SearchArtistsRow struct {
	ID            string
	Name          string
	Created       pgtype.Timestamptz
	Updated       pgtype.Timestamptz
	MusicBrainzID *string
	AlbumCount    int64
	Starred       pgtype.Timestamptz
	UserRating    *int32
	AvgRating     float64
}

func (q *Queries) SearchArtists(ctx context.Context, arg SearchArtistsParams) ([]*SearchArtistsRow, error) {
	rows, err := q.db.Query(ctx, searchArtists,
		arg.UserName,
		arg.Offset,
		arg.Limit,
		arg.SearchStr,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchArtistsRow
	for rows.Next() {
		var i SearchArtistsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Updated,
			&i.MusicBrainzID,
			&i.AlbumCount,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateArtist = `-- name: UpdateArtist :exec
UPDATE artists SET name = $2, music_brainz_id = $3, updated = NOW() WHERE id = $1
`

type UpdateArtistParams struct {
	ID            string
	Name          string
	MusicBrainzID *string
}

func (q *Queries) UpdateArtist(ctx context.Context, arg UpdateArtistParams) error {
	_, err := q.db.Exec(ctx, updateArtist, arg.ID, arg.Name, arg.MusicBrainzID)
	return err
}
