// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: songs.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSong = `-- name: CreateSong :one
INSERT INTO songs
(id, path, album_id, title, track, year, size, content_type, duration_ms, bit_rate, sampling_rate, channel_count, disc_number, created, updated, bpm, music_brainz_id, replay_gain, replay_gain_peak, lyrics, cover_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, NOW(), NOW(), $14, $15, $16, $17, $18, $19) RETURNING id, path, album_id, title, track, year, size, content_type, duration_ms, bit_rate, sampling_rate, channel_count, disc_number, created, updated, bpm, music_brainz_id, replay_gain, replay_gain_peak, lyrics, cover_id
`

type CreateSongParams struct {
	ID             string
	Path           string
	AlbumID        *string
	Title          string
	Track          *int32
	Year           *int32
	Size           int64
	ContentType    string
	DurationMs     int32
	BitRate        int32
	SamplingRate   int32
	ChannelCount   int32
	DiscNumber     *int32
	Bpm            *int32
	MusicBrainzID  *string
	ReplayGain     *float32
	ReplayGainPeak *float32
	Lyrics         *string
	CoverID        *string
}

func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) (*Song, error) {
	row := q.db.QueryRow(ctx, createSong,
		arg.ID,
		arg.Path,
		arg.AlbumID,
		arg.Title,
		arg.Track,
		arg.Year,
		arg.Size,
		arg.ContentType,
		arg.DurationMs,
		arg.BitRate,
		arg.SamplingRate,
		arg.ChannelCount,
		arg.DiscNumber,
		arg.Bpm,
		arg.MusicBrainzID,
		arg.ReplayGain,
		arg.ReplayGainPeak,
		arg.Lyrics,
		arg.CoverID,
	)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.AlbumID,
		&i.Title,
		&i.Track,
		&i.Year,
		&i.Size,
		&i.ContentType,
		&i.DurationMs,
		&i.BitRate,
		&i.SamplingRate,
		&i.ChannelCount,
		&i.DiscNumber,
		&i.Created,
		&i.Updated,
		&i.Bpm,
		&i.MusicBrainzID,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.Lyrics,
		&i.CoverID,
	)
	return &i, err
}

type CreateSongArtistsParams struct {
	SongID   string
	ArtistID string
}

type CreateSongGenresParams struct {
	SongID    string
	GenreName string
}

const deleteSongArtists = `-- name: DeleteSongArtists :exec
DELETE FROM song_artist WHERE song_id = $1
`

func (q *Queries) DeleteSongArtists(ctx context.Context, songID string) error {
	_, err := q.db.Exec(ctx, deleteSongArtists, songID)
	return err
}

const deleteSongGenres = `-- name: DeleteSongGenres :exec
DELETE FROM song_genre WHERE song_id = $1
`

func (q *Queries) DeleteSongGenres(ctx context.Context, songID string) error {
	_, err := q.db.Exec(ctx, deleteSongGenres, songID)
	return err
}

const deleteSongsLastUpdatedBefore = `-- name: DeleteSongsLastUpdatedBefore :exec
DELETE FROM songs WHERE updated < $1
`

func (q *Queries) DeleteSongsLastUpdatedBefore(ctx context.Context, updated pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteSongsLastUpdatedBefore, updated)
	return err
}

const findRandomSongs = `-- name: FindRandomSongs :many
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name, albums.replay_gain as album_replay_gain, albums.replay_gain_peak as album_replay_gain_peak, song_stars.created as starred, song_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM songs
LEFT JOIN albums ON albums.id = songs.album_id
LEFT JOIN song_stars ON song_stars.song_id = songs.id AND song_stars.user_name = $1
LEFT JOIN (
  SELECT song_id, AVG(song_ratings.rating) AS rating FROM song_ratings GROUP BY song_id
) avgr ON avgr.song_id = songs.id
LEFT JOIN song_ratings ON song_ratings.song_id = songs.id AND song_ratings.user_name = $1
WHERE (cast($3 as int) IS NULL OR (songs.year IS NOT NULL AND songs.year >= $3))
AND (cast($4 as int) IS NULL OR (songs.year IS NOT NULL AND songs.year <= $4))
AND ($5::text[] IS NULL OR EXISTS (
  SELECT song_genre.song_id, genres.name FROM song_genre
  JOIN genres ON song_genre.genre_name = genres.name
  WHERE song_genre.song_id = songs.id AND lower(song_genre.genre_name) = any($5::text[])
))
ORDER BY random()
LIMIT $2
`

type FindRandomSongsParams struct {
	UserName    string
	Limit       int32
	FromYear    *int32
	ToYear      *int32
	GenresLower []string
}

type FindRandomSongsRow struct {
	ID                  string
	Path                string
	AlbumID             *string
	Title               string
	Track               *int32
	Year                *int32
	Size                int64
	ContentType         string
	DurationMs          int32
	BitRate             int32
	SamplingRate        int32
	ChannelCount        int32
	DiscNumber          *int32
	Created             pgtype.Timestamptz
	Updated             pgtype.Timestamptz
	Bpm                 *int32
	MusicBrainzID       *string
	ReplayGain          *float32
	ReplayGainPeak      *float32
	Lyrics              *string
	CoverID             *string
	AlbumName           *string
	AlbumReplayGain     *float32
	AlbumReplayGainPeak *float32
	Starred             pgtype.Timestamptz
	UserRating          *int32
	AvgRating           float64
}

func (q *Queries) FindRandomSongs(ctx context.Context, arg FindRandomSongsParams) ([]*FindRandomSongsRow, error) {
	rows, err := q.db.Query(ctx, findRandomSongs,
		arg.UserName,
		arg.Limit,
		arg.FromYear,
		arg.ToYear,
		arg.GenresLower,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindRandomSongsRow
	for rows.Next() {
		var i FindRandomSongsRow
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.AlbumID,
			&i.Title,
			&i.Track,
			&i.Year,
			&i.Size,
			&i.ContentType,
			&i.DurationMs,
			&i.BitRate,
			&i.SamplingRate,
			&i.ChannelCount,
			&i.DiscNumber,
			&i.Created,
			&i.Updated,
			&i.Bpm,
			&i.MusicBrainzID,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.Lyrics,
			&i.CoverID,
			&i.AlbumName,
			&i.AlbumReplayGain,
			&i.AlbumReplayGainPeak,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSong = `-- name: FindSong :one
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name, albums.music_brainz_id as album_music_brainz_id, albums.release_mbid as album_release_mbid FROM songs LEFT JOIN albums ON songs.album_id = albums.id WHERE songs.id = $1
`

type FindSongRow struct {
	ID                 string
	Path               string
	AlbumID            *string
	Title              string
	Track              *int32
	Year               *int32
	Size               int64
	ContentType        string
	DurationMs         int32
	BitRate            int32
	SamplingRate       int32
	ChannelCount       int32
	DiscNumber         *int32
	Created            pgtype.Timestamptz
	Updated            pgtype.Timestamptz
	Bpm                *int32
	MusicBrainzID      *string
	ReplayGain         *float32
	ReplayGainPeak     *float32
	Lyrics             *string
	CoverID            *string
	AlbumName          *string
	AlbumMusicBrainzID *string
	AlbumReleaseMbid   *string
}

func (q *Queries) FindSong(ctx context.Context, id string) (*FindSongRow, error) {
	row := q.db.QueryRow(ctx, findSong, id)
	var i FindSongRow
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.AlbumID,
		&i.Title,
		&i.Track,
		&i.Year,
		&i.Size,
		&i.ContentType,
		&i.DurationMs,
		&i.BitRate,
		&i.SamplingRate,
		&i.ChannelCount,
		&i.DiscNumber,
		&i.Created,
		&i.Updated,
		&i.Bpm,
		&i.MusicBrainzID,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.Lyrics,
		&i.CoverID,
		&i.AlbumName,
		&i.AlbumMusicBrainzID,
		&i.AlbumReleaseMbid,
	)
	return &i, err
}

const findSongByPath = `-- name: FindSongByPath :one
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name FROM songs LEFT JOIN albums ON songs.album_id = albums.id WHERE songs.path = $1
`

type FindSongByPathRow struct {
	ID             string
	Path           string
	AlbumID        *string
	Title          string
	Track          *int32
	Year           *int32
	Size           int64
	ContentType    string
	DurationMs     int32
	BitRate        int32
	SamplingRate   int32
	ChannelCount   int32
	DiscNumber     *int32
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Bpm            *int32
	MusicBrainzID  *string
	ReplayGain     *float32
	ReplayGainPeak *float32
	Lyrics         *string
	CoverID        *string
	AlbumName      *string
}

func (q *Queries) FindSongByPath(ctx context.Context, path string) (*FindSongByPathRow, error) {
	row := q.db.QueryRow(ctx, findSongByPath, path)
	var i FindSongByPathRow
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.AlbumID,
		&i.Title,
		&i.Track,
		&i.Year,
		&i.Size,
		&i.ContentType,
		&i.DurationMs,
		&i.BitRate,
		&i.SamplingRate,
		&i.ChannelCount,
		&i.DiscNumber,
		&i.Created,
		&i.Updated,
		&i.Bpm,
		&i.MusicBrainzID,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.Lyrics,
		&i.CoverID,
		&i.AlbumName,
	)
	return &i, err
}

const findSongCount = `-- name: FindSongCount :one
SELECT COUNT(*) as song_count FROM songs
`

func (q *Queries) FindSongCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, findSongCount)
	var song_count int64
	err := row.Scan(&song_count)
	return song_count, err
}

const findSongWithoutAlbum = `-- name: FindSongWithoutAlbum :one
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id FROM songs WHERE songs.id = $1
`

func (q *Queries) FindSongWithoutAlbum(ctx context.Context, id string) (*Song, error) {
	row := q.db.QueryRow(ctx, findSongWithoutAlbum, id)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.AlbumID,
		&i.Title,
		&i.Track,
		&i.Year,
		&i.Size,
		&i.ContentType,
		&i.DurationMs,
		&i.BitRate,
		&i.SamplingRate,
		&i.ChannelCount,
		&i.DiscNumber,
		&i.Created,
		&i.Updated,
		&i.Bpm,
		&i.MusicBrainzID,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.Lyrics,
		&i.CoverID,
	)
	return &i, err
}

const findSongs = `-- name: FindSongs :many
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name, albums.music_brainz_id as album_music_brainz_id, albums.release_mbid as album_release_mbid FROM songs LEFT JOIN albums ON songs.album_id = albums.id WHERE songs.id = any($1::text[])
`

type FindSongsRow struct {
	ID                 string
	Path               string
	AlbumID            *string
	Title              string
	Track              *int32
	Year               *int32
	Size               int64
	ContentType        string
	DurationMs         int32
	BitRate            int32
	SamplingRate       int32
	ChannelCount       int32
	DiscNumber         *int32
	Created            pgtype.Timestamptz
	Updated            pgtype.Timestamptz
	Bpm                *int32
	MusicBrainzID      *string
	ReplayGain         *float32
	ReplayGainPeak     *float32
	Lyrics             *string
	CoverID            *string
	AlbumName          *string
	AlbumMusicBrainzID *string
	AlbumReleaseMbid   *string
}

func (q *Queries) FindSongs(ctx context.Context, songIds []string) ([]*FindSongsRow, error) {
	rows, err := q.db.Query(ctx, findSongs, songIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindSongsRow
	for rows.Next() {
		var i FindSongsRow
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.AlbumID,
			&i.Title,
			&i.Track,
			&i.Year,
			&i.Size,
			&i.ContentType,
			&i.DurationMs,
			&i.BitRate,
			&i.SamplingRate,
			&i.ChannelCount,
			&i.DiscNumber,
			&i.Created,
			&i.Updated,
			&i.Bpm,
			&i.MusicBrainzID,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.Lyrics,
			&i.CoverID,
			&i.AlbumName,
			&i.AlbumMusicBrainzID,
			&i.AlbumReleaseMbid,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSongsByAlbum = `-- name: FindSongsByAlbum :many
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name, albums.replay_gain as album_replay_gain, albums.replay_gain_peak as album_replay_gain_peak, song_stars.created as starred, song_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM songs
LEFT JOIN albums ON albums.id = songs.album_id
LEFT JOIN song_stars ON song_stars.song_id = songs.id AND song_stars.user_name = $1
LEFT JOIN (
  SELECT song_id, AVG(song_ratings.rating) AS rating FROM song_ratings GROUP BY song_id
) avgr ON avgr.song_id = songs.id
LEFT JOIN song_ratings ON song_ratings.song_id = songs.id AND song_ratings.user_name = $1
WHERE albums.id = $2
ORDER BY songs.disc_number, songs.track
`

type FindSongsByAlbumParams struct {
	UserName string
	ID       string
}

type FindSongsByAlbumRow struct {
	ID                  string
	Path                string
	AlbumID             *string
	Title               string
	Track               *int32
	Year                *int32
	Size                int64
	ContentType         string
	DurationMs          int32
	BitRate             int32
	SamplingRate        int32
	ChannelCount        int32
	DiscNumber          *int32
	Created             pgtype.Timestamptz
	Updated             pgtype.Timestamptz
	Bpm                 *int32
	MusicBrainzID       *string
	ReplayGain          *float32
	ReplayGainPeak      *float32
	Lyrics              *string
	CoverID             *string
	AlbumName           *string
	AlbumReplayGain     *float32
	AlbumReplayGainPeak *float32
	Starred             pgtype.Timestamptz
	UserRating          *int32
	AvgRating           float64
}

func (q *Queries) FindSongsByAlbum(ctx context.Context, arg FindSongsByAlbumParams) ([]*FindSongsByAlbumRow, error) {
	rows, err := q.db.Query(ctx, findSongsByAlbum, arg.UserName, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindSongsByAlbumRow
	for rows.Next() {
		var i FindSongsByAlbumRow
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.AlbumID,
			&i.Title,
			&i.Track,
			&i.Year,
			&i.Size,
			&i.ContentType,
			&i.DurationMs,
			&i.BitRate,
			&i.SamplingRate,
			&i.ChannelCount,
			&i.DiscNumber,
			&i.Created,
			&i.Updated,
			&i.Bpm,
			&i.MusicBrainzID,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.Lyrics,
			&i.CoverID,
			&i.AlbumName,
			&i.AlbumReplayGain,
			&i.AlbumReplayGainPeak,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSongsByMusicBrainzID = `-- name: FindSongsByMusicBrainzID :many
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name, albums.music_brainz_id as album_music_brainz_id, albums.release_mbid as album_release_mbid FROM songs LEFT JOIN albums ON songs.album_id = albums.id WHERE songs.music_brainz_id = $1
`

type FindSongsByMusicBrainzIDRow struct {
	ID                 string
	Path               string
	AlbumID            *string
	Title              string
	Track              *int32
	Year               *int32
	Size               int64
	ContentType        string
	DurationMs         int32
	BitRate            int32
	SamplingRate       int32
	ChannelCount       int32
	DiscNumber         *int32
	Created            pgtype.Timestamptz
	Updated            pgtype.Timestamptz
	Bpm                *int32
	MusicBrainzID      *string
	ReplayGain         *float32
	ReplayGainPeak     *float32
	Lyrics             *string
	CoverID            *string
	AlbumName          *string
	AlbumMusicBrainzID *string
	AlbumReleaseMbid   *string
}

func (q *Queries) FindSongsByMusicBrainzID(ctx context.Context, musicBrainzID *string) ([]*FindSongsByMusicBrainzIDRow, error) {
	rows, err := q.db.Query(ctx, findSongsByMusicBrainzID, musicBrainzID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindSongsByMusicBrainzIDRow
	for rows.Next() {
		var i FindSongsByMusicBrainzIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.AlbumID,
			&i.Title,
			&i.Track,
			&i.Year,
			&i.Size,
			&i.ContentType,
			&i.DurationMs,
			&i.BitRate,
			&i.SamplingRate,
			&i.ChannelCount,
			&i.DiscNumber,
			&i.Created,
			&i.Updated,
			&i.Bpm,
			&i.MusicBrainzID,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.Lyrics,
			&i.CoverID,
			&i.AlbumName,
			&i.AlbumMusicBrainzID,
			&i.AlbumReleaseMbid,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMedianReplayGain = `-- name: GetMedianReplayGain :one
SELECT COALESCE(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY songs.replay_gain), 0) FROM songs
`

func (q *Queries) GetMedianReplayGain(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, getMedianReplayGain)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const getStreamInfo = `-- name: GetStreamInfo :one
SELECT songs.path, songs.bit_rate, songs.content_type, songs.duration_ms, songs.channel_count FROM songs WHERE songs.id = $1
`

type GetStreamInfoRow struct {
	Path         string
	BitRate      int32
	ContentType  string
	DurationMs   int32
	ChannelCount int32
}

func (q *Queries) GetStreamInfo(ctx context.Context, id string) (*GetStreamInfoRow, error) {
	row := q.db.QueryRow(ctx, getStreamInfo, id)
	var i GetStreamInfoRow
	err := row.Scan(
		&i.Path,
		&i.BitRate,
		&i.ContentType,
		&i.DurationMs,
		&i.ChannelCount,
	)
	return &i, err
}

const searchSongs = `-- name: SearchSongs :many
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name, albums.replay_gain as album_replay_gain, albums.replay_gain_peak as album_replay_gain_peak, song_stars.created as starred, song_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM songs
LEFT JOIN albums ON albums.id = songs.album_id
LEFT JOIN song_stars ON song_stars.song_id = songs.id AND song_stars.user_name = $1
LEFT JOIN (
  SELECT song_id, AVG(song_ratings.rating) AS rating FROM song_ratings GROUP BY song_id
) avgr ON avgr.song_id = songs.id
LEFT JOIN song_ratings ON song_ratings.song_id = songs.id AND song_ratings.user_name = $1
WHERE position(lower($4) in lower(songs.title)) > 0
ORDER BY position(lower($4) in lower(songs.title)), lower(songs.title)
OFFSET $2 LIMIT $3
`

type SearchSongsParams struct {
	UserName  string
	Offset    int32
	Limit     int32
	SearchStr string
}

type SearchSongsRow struct {
	ID                  string
	Path                string
	AlbumID             *string
	Title               string
	Track               *int32
	Year                *int32
	Size                int64
	ContentType         string
	DurationMs          int32
	BitRate             int32
	SamplingRate        int32
	ChannelCount        int32
	DiscNumber          *int32
	Created             pgtype.Timestamptz
	Updated             pgtype.Timestamptz
	Bpm                 *int32
	MusicBrainzID       *string
	ReplayGain          *float32
	ReplayGainPeak      *float32
	Lyrics              *string
	CoverID             *string
	AlbumName           *string
	AlbumReplayGain     *float32
	AlbumReplayGainPeak *float32
	Starred             pgtype.Timestamptz
	UserRating          *int32
	AvgRating           float64
}

func (q *Queries) SearchSongs(ctx context.Context, arg SearchSongsParams) ([]*SearchSongsRow, error) {
	rows, err := q.db.Query(ctx, searchSongs,
		arg.UserName,
		arg.Offset,
		arg.Limit,
		arg.SearchStr,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchSongsRow
	for rows.Next() {
		var i SearchSongsRow
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.AlbumID,
			&i.Title,
			&i.Track,
			&i.Year,
			&i.Size,
			&i.ContentType,
			&i.DurationMs,
			&i.BitRate,
			&i.SamplingRate,
			&i.ChannelCount,
			&i.DiscNumber,
			&i.Created,
			&i.Updated,
			&i.Bpm,
			&i.MusicBrainzID,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.Lyrics,
			&i.CoverID,
			&i.AlbumName,
			&i.AlbumReplayGain,
			&i.AlbumReplayGainPeak,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSong = `-- name: UpdateSong :exec
UPDATE songs SET path=$2,album_id=$3,title=$4,track=$5,year=$6,size=$7,content_type=$8,duration_ms=$9,bit_rate=$10,sampling_rate=$11,channel_count=$12,disc_number=$13,updated=NOW(),bpm=$14,music_brainz_id=$15,replay_gain=$16,replay_gain_peak=$17,lyrics=$18,cover_id=$19
WHERE id = $1
`

type UpdateSongParams struct {
	ID             string
	Path           string
	AlbumID        *string
	Title          string
	Track          *int32
	Year           *int32
	Size           int64
	ContentType    string
	DurationMs     int32
	BitRate        int32
	SamplingRate   int32
	ChannelCount   int32
	DiscNumber     *int32
	Bpm            *int32
	MusicBrainzID  *string
	ReplayGain     *float32
	ReplayGainPeak *float32
	Lyrics         *string
	CoverID        *string
}

func (q *Queries) UpdateSong(ctx context.Context, arg UpdateSongParams) error {
	_, err := q.db.Exec(ctx, updateSong,
		arg.ID,
		arg.Path,
		arg.AlbumID,
		arg.Title,
		arg.Track,
		arg.Year,
		arg.Size,
		arg.ContentType,
		arg.DurationMs,
		arg.BitRate,
		arg.SamplingRate,
		arg.ChannelCount,
		arg.DiscNumber,
		arg.Bpm,
		arg.MusicBrainzID,
		arg.ReplayGain,
		arg.ReplayGainPeak,
		arg.Lyrics,
		arg.CoverID,
	)
	return err
}
