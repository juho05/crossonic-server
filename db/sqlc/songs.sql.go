// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: songs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSong = `-- name: CreateSong :one
INSERT INTO songs
(id, path, album_id, title, track, year, size, content_type, duration_ms, bit_rate, sampling_rate, channel_count, disc_number, created, updated, bpm, music_brainz_id, replay_gain, replay_gain_peak, lyrics, cover_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, NOW(), NOW(), $14, $15, $16, $17, $18, $19) RETURNING id, path, album_id, title, track, year, size, content_type, duration_ms, bit_rate, sampling_rate, channel_count, disc_number, created, updated, bpm, music_brainz_id, replay_gain, replay_gain_peak, lyrics, cover_id
`

type CreateSongParams struct {
	ID             string
	Path           string
	AlbumID        *string
	Title          string
	Track          *int32
	Year           *int32
	Size           int64
	ContentType    string
	DurationMs     int32
	BitRate        int32
	SamplingRate   int32
	ChannelCount   int32
	DiscNumber     *int32
	Bpm            *int32
	MusicBrainzID  *string
	ReplayGain     *float32
	ReplayGainPeak *float32
	Lyrics         *string
	CoverID        *string
}

func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) (*Song, error) {
	row := q.db.QueryRow(ctx, createSong,
		arg.ID,
		arg.Path,
		arg.AlbumID,
		arg.Title,
		arg.Track,
		arg.Year,
		arg.Size,
		arg.ContentType,
		arg.DurationMs,
		arg.BitRate,
		arg.SamplingRate,
		arg.ChannelCount,
		arg.DiscNumber,
		arg.Bpm,
		arg.MusicBrainzID,
		arg.ReplayGain,
		arg.ReplayGainPeak,
		arg.Lyrics,
		arg.CoverID,
	)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.AlbumID,
		&i.Title,
		&i.Track,
		&i.Year,
		&i.Size,
		&i.ContentType,
		&i.DurationMs,
		&i.BitRate,
		&i.SamplingRate,
		&i.ChannelCount,
		&i.DiscNumber,
		&i.Created,
		&i.Updated,
		&i.Bpm,
		&i.MusicBrainzID,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.Lyrics,
		&i.CoverID,
	)
	return &i, err
}

type CreateSongArtistsParams struct {
	SongID   string
	ArtistID string
}

type CreateSongGenresParams struct {
	SongID    string
	GenreName string
}

const deleteSongArtists = `-- name: DeleteSongArtists :exec
DELETE FROM song_artist WHERE song_id = $1
`

func (q *Queries) DeleteSongArtists(ctx context.Context, songID string) error {
	_, err := q.db.Exec(ctx, deleteSongArtists, songID)
	return err
}

const deleteSongGenres = `-- name: DeleteSongGenres :exec
DELETE FROM song_genre WHERE song_id = $1
`

func (q *Queries) DeleteSongGenres(ctx context.Context, songID string) error {
	_, err := q.db.Exec(ctx, deleteSongGenres, songID)
	return err
}

const deleteSongsLastUpdatedBefore = `-- name: DeleteSongsLastUpdatedBefore :exec
DELETE FROM songs WHERE updated < $1
`

func (q *Queries) DeleteSongsLastUpdatedBefore(ctx context.Context, updated pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteSongsLastUpdatedBefore, updated)
	return err
}

const findRandomSongs = `-- name: FindRandomSongs :many
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name, albums.replay_gain as album_replay_gain, albums.replay_gain_peak as album_replay_gain_peak, song_stars.created as starred, song_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM songs
LEFT JOIN albums ON albums.id = songs.album_id
LEFT JOIN song_stars ON song_stars.song_id = songs.id AND song_stars.user_name = $1
LEFT JOIN (
  SELECT song_id, AVG(song_ratings.rating) AS rating FROM song_ratings GROUP BY song_id
) avgr ON avgr.song_id = songs.id
LEFT JOIN song_ratings ON song_ratings.song_id = songs.id AND song_ratings.user_name = $1
WHERE (cast($3 as int) IS NULL OR (songs.year IS NOT NULL AND songs.year >= $3))
AND (cast($4 as int) IS NULL OR (songs.year IS NOT NULL AND songs.year <= $4))
AND ($5::text[] IS NULL OR EXISTS (
  SELECT song_genre.song_id, genres.name FROM song_genre
  JOIN genres ON song_genre.genre_name = genres.name
  WHERE song_genre.song_id = songs.id AND lower(song_genre.genre_name) = any($5::text[])
))
ORDER BY random()
LIMIT $2
`

type FindRandomSongsParams struct {
	UserName    string
	Limit       int32
	FromYear    *int32
	ToYear      *int32
	GenresLower []string
}

type FindRandomSongsRow struct {
	ID                  string
	Path                string
	AlbumID             *string
	Title               string
	Track               *int32
	Year                *int32
	Size                int64
	ContentType         string
	DurationMs          int32
	BitRate             int32
	SamplingRate        int32
	ChannelCount        int32
	DiscNumber          *int32
	Created             pgtype.Timestamptz
	Updated             pgtype.Timestamptz
	Bpm                 *int32
	MusicBrainzID       *string
	ReplayGain          *float32
	ReplayGainPeak      *float32
	Lyrics              *string
	CoverID             *string
	AlbumName           *string
	AlbumReplayGain     *float32
	AlbumReplayGainPeak *float32
	Starred             pgtype.Timestamptz
	UserRating          *int32
	AvgRating           float64
}

func (q *Queries) FindRandomSongs(ctx context.Context, arg FindRandomSongsParams) ([]*FindRandomSongsRow, error) {
	rows, err := q.db.Query(ctx, findRandomSongs,
		arg.UserName,
		arg.Limit,
		arg.FromYear,
		arg.ToYear,
		arg.GenresLower,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindRandomSongsRow
	for rows.Next() {
		var i FindRandomSongsRow
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.AlbumID,
			&i.Title,
			&i.Track,
			&i.Year,
			&i.Size,
			&i.ContentType,
			&i.DurationMs,
			&i.BitRate,
			&i.SamplingRate,
			&i.ChannelCount,
			&i.DiscNumber,
			&i.Created,
			&i.Updated,
			&i.Bpm,
			&i.MusicBrainzID,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.Lyrics,
			&i.CoverID,
			&i.AlbumName,
			&i.AlbumReplayGain,
			&i.AlbumReplayGainPeak,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSong = `-- name: FindSong :one
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name FROM songs LEFT JOIN albums ON songs.album_id = albums.id WHERE songs.id = $1
`

type FindSongRow struct {
	ID             string
	Path           string
	AlbumID        *string
	Title          string
	Track          *int32
	Year           *int32
	Size           int64
	ContentType    string
	DurationMs     int32
	BitRate        int32
	SamplingRate   int32
	ChannelCount   int32
	DiscNumber     *int32
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Bpm            *int32
	MusicBrainzID  *string
	ReplayGain     *float32
	ReplayGainPeak *float32
	Lyrics         *string
	CoverID        *string
	AlbumName      *string
}

func (q *Queries) FindSong(ctx context.Context, id string) (*FindSongRow, error) {
	row := q.db.QueryRow(ctx, findSong, id)
	var i FindSongRow
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.AlbumID,
		&i.Title,
		&i.Track,
		&i.Year,
		&i.Size,
		&i.ContentType,
		&i.DurationMs,
		&i.BitRate,
		&i.SamplingRate,
		&i.ChannelCount,
		&i.DiscNumber,
		&i.Created,
		&i.Updated,
		&i.Bpm,
		&i.MusicBrainzID,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.Lyrics,
		&i.CoverID,
		&i.AlbumName,
	)
	return &i, err
}

const findSongByMusicBrainzID = `-- name: FindSongByMusicBrainzID :one
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name FROM songs LEFT JOIN albums ON songs.album_id = albums.id WHERE songs.music_brainz_id = $1
`

type FindSongByMusicBrainzIDRow struct {
	ID             string
	Path           string
	AlbumID        *string
	Title          string
	Track          *int32
	Year           *int32
	Size           int64
	ContentType    string
	DurationMs     int32
	BitRate        int32
	SamplingRate   int32
	ChannelCount   int32
	DiscNumber     *int32
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Bpm            *int32
	MusicBrainzID  *string
	ReplayGain     *float32
	ReplayGainPeak *float32
	Lyrics         *string
	CoverID        *string
	AlbumName      *string
}

func (q *Queries) FindSongByMusicBrainzID(ctx context.Context, musicBrainzID *string) (*FindSongByMusicBrainzIDRow, error) {
	row := q.db.QueryRow(ctx, findSongByMusicBrainzID, musicBrainzID)
	var i FindSongByMusicBrainzIDRow
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.AlbumID,
		&i.Title,
		&i.Track,
		&i.Year,
		&i.Size,
		&i.ContentType,
		&i.DurationMs,
		&i.BitRate,
		&i.SamplingRate,
		&i.ChannelCount,
		&i.DiscNumber,
		&i.Created,
		&i.Updated,
		&i.Bpm,
		&i.MusicBrainzID,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.Lyrics,
		&i.CoverID,
		&i.AlbumName,
	)
	return &i, err
}

const findSongByPath = `-- name: FindSongByPath :one
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name FROM songs LEFT JOIN albums ON songs.album_id = albums.id WHERE songs.path = $1
`

type FindSongByPathRow struct {
	ID             string
	Path           string
	AlbumID        *string
	Title          string
	Track          *int32
	Year           *int32
	Size           int64
	ContentType    string
	DurationMs     int32
	BitRate        int32
	SamplingRate   int32
	ChannelCount   int32
	DiscNumber     *int32
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Bpm            *int32
	MusicBrainzID  *string
	ReplayGain     *float32
	ReplayGainPeak *float32
	Lyrics         *string
	CoverID        *string
	AlbumName      *string
}

func (q *Queries) FindSongByPath(ctx context.Context, path string) (*FindSongByPathRow, error) {
	row := q.db.QueryRow(ctx, findSongByPath, path)
	var i FindSongByPathRow
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.AlbumID,
		&i.Title,
		&i.Track,
		&i.Year,
		&i.Size,
		&i.ContentType,
		&i.DurationMs,
		&i.BitRate,
		&i.SamplingRate,
		&i.ChannelCount,
		&i.DiscNumber,
		&i.Created,
		&i.Updated,
		&i.Bpm,
		&i.MusicBrainzID,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.Lyrics,
		&i.CoverID,
		&i.AlbumName,
	)
	return &i, err
}

const findSongCount = `-- name: FindSongCount :one
SELECT COUNT(*) as song_count FROM songs
`

func (q *Queries) FindSongCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, findSongCount)
	var song_count int64
	err := row.Scan(&song_count)
	return song_count, err
}

const findSongWithoutAlbum = `-- name: FindSongWithoutAlbum :one
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id FROM songs WHERE songs.id = $1
`

func (q *Queries) FindSongWithoutAlbum(ctx context.Context, id string) (*Song, error) {
	row := q.db.QueryRow(ctx, findSongWithoutAlbum, id)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.AlbumID,
		&i.Title,
		&i.Track,
		&i.Year,
		&i.Size,
		&i.ContentType,
		&i.DurationMs,
		&i.BitRate,
		&i.SamplingRate,
		&i.ChannelCount,
		&i.DiscNumber,
		&i.Created,
		&i.Updated,
		&i.Bpm,
		&i.MusicBrainzID,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.Lyrics,
		&i.CoverID,
	)
	return &i, err
}

const findSongsByAlbum = `-- name: FindSongsByAlbum :many
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name, albums.replay_gain as album_replay_gain, albums.replay_gain_peak as album_replay_gain_peak, song_stars.created as starred, song_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM songs
LEFT JOIN albums ON albums.id = songs.album_id
LEFT JOIN song_stars ON song_stars.song_id = songs.id AND song_stars.user_name = $1
LEFT JOIN (
  SELECT song_id, AVG(song_ratings.rating) AS rating FROM song_ratings GROUP BY song_id
) avgr ON avgr.song_id = songs.id
LEFT JOIN song_ratings ON song_ratings.song_id = songs.id AND song_ratings.user_name = $1
WHERE albums.id = $2
ORDER BY songs.disc_number, songs.track
`

type FindSongsByAlbumParams struct {
	UserName string
	ID       string
}

type FindSongsByAlbumRow struct {
	ID                  string
	Path                string
	AlbumID             *string
	Title               string
	Track               *int32
	Year                *int32
	Size                int64
	ContentType         string
	DurationMs          int32
	BitRate             int32
	SamplingRate        int32
	ChannelCount        int32
	DiscNumber          *int32
	Created             pgtype.Timestamptz
	Updated             pgtype.Timestamptz
	Bpm                 *int32
	MusicBrainzID       *string
	ReplayGain          *float32
	ReplayGainPeak      *float32
	Lyrics              *string
	CoverID             *string
	AlbumName           *string
	AlbumReplayGain     *float32
	AlbumReplayGainPeak *float32
	Starred             pgtype.Timestamptz
	UserRating          *int32
	AvgRating           float64
}

func (q *Queries) FindSongsByAlbum(ctx context.Context, arg FindSongsByAlbumParams) ([]*FindSongsByAlbumRow, error) {
	rows, err := q.db.Query(ctx, findSongsByAlbum, arg.UserName, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindSongsByAlbumRow
	for rows.Next() {
		var i FindSongsByAlbumRow
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.AlbumID,
			&i.Title,
			&i.Track,
			&i.Year,
			&i.Size,
			&i.ContentType,
			&i.DurationMs,
			&i.BitRate,
			&i.SamplingRate,
			&i.ChannelCount,
			&i.DiscNumber,
			&i.Created,
			&i.Updated,
			&i.Bpm,
			&i.MusicBrainzID,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.Lyrics,
			&i.CoverID,
			&i.AlbumName,
			&i.AlbumReplayGain,
			&i.AlbumReplayGainPeak,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSongPath = `-- name: GetSongPath :one
SELECT songs.path FROM songs WHERE songs.id = $1
`

func (q *Queries) GetSongPath(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, getSongPath, id)
	var path string
	err := row.Scan(&path)
	return path, err
}

const updateSong = `-- name: UpdateSong :exec
UPDATE songs SET path=$2,album_id=$3,title=$4,track=$5,year=$6,size=$7,content_type=$8,duration_ms=$9,bit_rate=$10,sampling_rate=$11,channel_count=$12,disc_number=$13,updated=NOW(),bpm=$14,music_brainz_id=$15,replay_gain=$16,replay_gain_peak=$17,lyrics=$18,cover_id=$19
WHERE id = $1
`

type UpdateSongParams struct {
	ID             string
	Path           string
	AlbumID        *string
	Title          string
	Track          *int32
	Year           *int32
	Size           int64
	ContentType    string
	DurationMs     int32
	BitRate        int32
	SamplingRate   int32
	ChannelCount   int32
	DiscNumber     *int32
	Bpm            *int32
	MusicBrainzID  *string
	ReplayGain     *float32
	ReplayGainPeak *float32
	Lyrics         *string
	CoverID        *string
}

func (q *Queries) UpdateSong(ctx context.Context, arg UpdateSongParams) error {
	_, err := q.db.Exec(ctx, updateSong,
		arg.ID,
		arg.Path,
		arg.AlbumID,
		arg.Title,
		arg.Track,
		arg.Year,
		arg.Size,
		arg.ContentType,
		arg.DurationMs,
		arg.BitRate,
		arg.SamplingRate,
		arg.ChannelCount,
		arg.DiscNumber,
		arg.Bpm,
		arg.MusicBrainzID,
		arg.ReplayGain,
		arg.ReplayGainPeak,
		arg.Lyrics,
		arg.CoverID,
	)
	return err
}
