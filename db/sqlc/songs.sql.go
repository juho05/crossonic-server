// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: songs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSong = `-- name: CreateSong :one
INSERT INTO songs
(id, path, album_id, title, track, year, size, content_type, duration_ms, bit_rate, sampling_rate, channel_count, disc_number, created, updated, bpm, music_brainz_id, replay_gain, replay_gain_peak, lyrics, cover_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, NOW(), NOW(), $14, $15, $16, $17, $18, $19) RETURNING id, path, album_id, title, track, year, size, content_type, duration_ms, bit_rate, sampling_rate, channel_count, disc_number, created, updated, bpm, music_brainz_id, replay_gain, replay_gain_peak, lyrics, cover_id
`

type CreateSongParams struct {
	ID             string
	Path           string
	AlbumID        *string
	Title          string
	Track          *int32
	Year           *int32
	Size           int64
	ContentType    string
	DurationMs     int32
	BitRate        int32
	SamplingRate   int32
	ChannelCount   int32
	DiscNumber     *int32
	Bpm            *int32
	MusicBrainzID  *string
	ReplayGain     *float32
	ReplayGainPeak *float32
	Lyrics         *string
	CoverID        *string
}

func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) (*Song, error) {
	row := q.db.QueryRow(ctx, createSong,
		arg.ID,
		arg.Path,
		arg.AlbumID,
		arg.Title,
		arg.Track,
		arg.Year,
		arg.Size,
		arg.ContentType,
		arg.DurationMs,
		arg.BitRate,
		arg.SamplingRate,
		arg.ChannelCount,
		arg.DiscNumber,
		arg.Bpm,
		arg.MusicBrainzID,
		arg.ReplayGain,
		arg.ReplayGainPeak,
		arg.Lyrics,
		arg.CoverID,
	)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.AlbumID,
		&i.Title,
		&i.Track,
		&i.Year,
		&i.Size,
		&i.ContentType,
		&i.DurationMs,
		&i.BitRate,
		&i.SamplingRate,
		&i.ChannelCount,
		&i.DiscNumber,
		&i.Created,
		&i.Updated,
		&i.Bpm,
		&i.MusicBrainzID,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.Lyrics,
		&i.CoverID,
	)
	return &i, err
}

type CreateSongArtistsParams struct {
	SongID   string
	ArtistID string
}

type CreateSongGenresParams struct {
	SongID    string
	GenreName string
}

const deleteSongArtists = `-- name: DeleteSongArtists :exec
DELETE FROM song_artist WHERE song_id = $1
`

func (q *Queries) DeleteSongArtists(ctx context.Context, songID string) error {
	_, err := q.db.Exec(ctx, deleteSongArtists, songID)
	return err
}

const deleteSongGenres = `-- name: DeleteSongGenres :exec
DELETE FROM song_genre WHERE song_id = $1
`

func (q *Queries) DeleteSongGenres(ctx context.Context, songID string) error {
	_, err := q.db.Exec(ctx, deleteSongGenres, songID)
	return err
}

const deleteSongsLastUpdatedBefore = `-- name: DeleteSongsLastUpdatedBefore :exec
DELETE FROM songs WHERE updated < $1
`

func (q *Queries) DeleteSongsLastUpdatedBefore(ctx context.Context, updated pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteSongsLastUpdatedBefore, updated)
	return err
}

const findSong = `-- name: FindSong :one
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name FROM songs LEFT JOIN albums ON songs.album_id = albums.id WHERE songs.id = $1
`

type FindSongRow struct {
	ID             string
	Path           string
	AlbumID        *string
	Title          string
	Track          *int32
	Year           *int32
	Size           int64
	ContentType    string
	DurationMs     int32
	BitRate        int32
	SamplingRate   int32
	ChannelCount   int32
	DiscNumber     *int32
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Bpm            *int32
	MusicBrainzID  *string
	ReplayGain     *float32
	ReplayGainPeak *float32
	Lyrics         *string
	CoverID        *string
	AlbumName      *string
}

func (q *Queries) FindSong(ctx context.Context, id string) (*FindSongRow, error) {
	row := q.db.QueryRow(ctx, findSong, id)
	var i FindSongRow
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.AlbumID,
		&i.Title,
		&i.Track,
		&i.Year,
		&i.Size,
		&i.ContentType,
		&i.DurationMs,
		&i.BitRate,
		&i.SamplingRate,
		&i.ChannelCount,
		&i.DiscNumber,
		&i.Created,
		&i.Updated,
		&i.Bpm,
		&i.MusicBrainzID,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.Lyrics,
		&i.CoverID,
		&i.AlbumName,
	)
	return &i, err
}

const findSongByMusicBrainzID = `-- name: FindSongByMusicBrainzID :one
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name FROM songs LEFT JOIN albums ON songs.album_id = albums.id WHERE songs.music_brainz_id = $1
`

type FindSongByMusicBrainzIDRow struct {
	ID             string
	Path           string
	AlbumID        *string
	Title          string
	Track          *int32
	Year           *int32
	Size           int64
	ContentType    string
	DurationMs     int32
	BitRate        int32
	SamplingRate   int32
	ChannelCount   int32
	DiscNumber     *int32
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Bpm            *int32
	MusicBrainzID  *string
	ReplayGain     *float32
	ReplayGainPeak *float32
	Lyrics         *string
	CoverID        *string
	AlbumName      *string
}

func (q *Queries) FindSongByMusicBrainzID(ctx context.Context, musicBrainzID *string) (*FindSongByMusicBrainzIDRow, error) {
	row := q.db.QueryRow(ctx, findSongByMusicBrainzID, musicBrainzID)
	var i FindSongByMusicBrainzIDRow
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.AlbumID,
		&i.Title,
		&i.Track,
		&i.Year,
		&i.Size,
		&i.ContentType,
		&i.DurationMs,
		&i.BitRate,
		&i.SamplingRate,
		&i.ChannelCount,
		&i.DiscNumber,
		&i.Created,
		&i.Updated,
		&i.Bpm,
		&i.MusicBrainzID,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.Lyrics,
		&i.CoverID,
		&i.AlbumName,
	)
	return &i, err
}

const findSongByPath = `-- name: FindSongByPath :one
SELECT songs.id, songs.path, songs.album_id, songs.title, songs.track, songs.year, songs.size, songs.content_type, songs.duration_ms, songs.bit_rate, songs.sampling_rate, songs.channel_count, songs.disc_number, songs.created, songs.updated, songs.bpm, songs.music_brainz_id, songs.replay_gain, songs.replay_gain_peak, songs.lyrics, songs.cover_id, albums.name as album_name FROM songs LEFT JOIN albums ON songs.album_id = albums.id WHERE songs.path = $1
`

type FindSongByPathRow struct {
	ID             string
	Path           string
	AlbumID        *string
	Title          string
	Track          *int32
	Year           *int32
	Size           int64
	ContentType    string
	DurationMs     int32
	BitRate        int32
	SamplingRate   int32
	ChannelCount   int32
	DiscNumber     *int32
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Bpm            *int32
	MusicBrainzID  *string
	ReplayGain     *float32
	ReplayGainPeak *float32
	Lyrics         *string
	CoverID        *string
	AlbumName      *string
}

func (q *Queries) FindSongByPath(ctx context.Context, path string) (*FindSongByPathRow, error) {
	row := q.db.QueryRow(ctx, findSongByPath, path)
	var i FindSongByPathRow
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.AlbumID,
		&i.Title,
		&i.Track,
		&i.Year,
		&i.Size,
		&i.ContentType,
		&i.DurationMs,
		&i.BitRate,
		&i.SamplingRate,
		&i.ChannelCount,
		&i.DiscNumber,
		&i.Created,
		&i.Updated,
		&i.Bpm,
		&i.MusicBrainzID,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.Lyrics,
		&i.CoverID,
		&i.AlbumName,
	)
	return &i, err
}

const findSongCount = `-- name: FindSongCount :one
SELECT COUNT(*) as song_count FROM songs
`

func (q *Queries) FindSongCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, findSongCount)
	var song_count int64
	err := row.Scan(&song_count)
	return song_count, err
}

const updateSong = `-- name: UpdateSong :exec
UPDATE songs SET path=$2,album_id=$3,title=$4,track=$5,year=$6,size=$7,content_type=$8,duration_ms=$9,bit_rate=$10,sampling_rate=$11,channel_count=$12,disc_number=$13,updated=NOW(),bpm=$14,music_brainz_id=$15,replay_gain=$16,replay_gain_peak=$17,lyrics=$18,cover_id=$19
WHERE id = $1
`

type UpdateSongParams struct {
	ID             string
	Path           string
	AlbumID        *string
	Title          string
	Track          *int32
	Year           *int32
	Size           int64
	ContentType    string
	DurationMs     int32
	BitRate        int32
	SamplingRate   int32
	ChannelCount   int32
	DiscNumber     *int32
	Bpm            *int32
	MusicBrainzID  *string
	ReplayGain     *float32
	ReplayGainPeak *float32
	Lyrics         *string
	CoverID        *string
}

func (q *Queries) UpdateSong(ctx context.Context, arg UpdateSongParams) error {
	_, err := q.db.Exec(ctx, updateSong,
		arg.ID,
		arg.Path,
		arg.AlbumID,
		arg.Title,
		arg.Track,
		arg.Year,
		arg.Size,
		arg.ContentType,
		arg.DurationMs,
		arg.BitRate,
		arg.SamplingRate,
		arg.ChannelCount,
		arg.DiscNumber,
		arg.Bpm,
		arg.MusicBrainzID,
		arg.ReplayGain,
		arg.ReplayGainPeak,
		arg.Lyrics,
		arg.CoverID,
	)
	return err
}
