// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: albums.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAlbum = `-- name: CreateAlbum :one
INSERT INTO albums
(id, name, created, updated, year, record_labels, music_brainz_id, release_types, is_compilation, replay_gain, replay_gain_peak)
VALUES($1, $2, NOW(), NOW(), $3, $4, $5, $6, $7, $8, $9)
RETURNING id, name, created, updated, year, record_labels, music_brainz_id, release_types, is_compilation, replay_gain, replay_gain_peak
`

type CreateAlbumParams struct {
	ID             string
	Name           string
	Year           *int32
	RecordLabels   *string
	MusicBrainzID  *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
}

func (q *Queries) CreateAlbum(ctx context.Context, arg CreateAlbumParams) (*Album, error) {
	row := q.db.QueryRow(ctx, createAlbum,
		arg.ID,
		arg.Name,
		arg.Year,
		arg.RecordLabels,
		arg.MusicBrainzID,
		arg.ReleaseTypes,
		arg.IsCompilation,
		arg.ReplayGain,
		arg.ReplayGainPeak,
	)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Created,
		&i.Updated,
		&i.Year,
		&i.RecordLabels,
		&i.MusicBrainzID,
		&i.ReleaseTypes,
		&i.IsCompilation,
		&i.ReplayGain,
		&i.ReplayGainPeak,
	)
	return &i, err
}

type CreateAlbumArtistsParams struct {
	AlbumID  string
	ArtistID string
}

type CreateAlbumGenresParams struct {
	AlbumID   string
	GenreName string
}

const deleteAlbumArtists = `-- name: DeleteAlbumArtists :exec
DELETE FROM album_artist WHERE album_id = $1
`

func (q *Queries) DeleteAlbumArtists(ctx context.Context, albumID string) error {
	_, err := q.db.Exec(ctx, deleteAlbumArtists, albumID)
	return err
}

const deleteAlbumGenres = `-- name: DeleteAlbumGenres :exec
DELETE FROM album_genre WHERE album_id = $1
`

func (q *Queries) DeleteAlbumGenres(ctx context.Context, albumID string) error {
	_, err := q.db.Exec(ctx, deleteAlbumGenres, albumID)
	return err
}

const deleteAlbumsLastUpdatedBefore = `-- name: DeleteAlbumsLastUpdatedBefore :exec
DELETE FROM albums WHERE updated < $1
`

func (q *Queries) DeleteAlbumsLastUpdatedBefore(ctx context.Context, updated pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteAlbumsLastUpdatedBefore, updated)
	return err
}

const findAlbum = `-- name: FindAlbum :one
SELECT albums.id, albums.name, albums.created, albums.updated, albums.year, albums.record_labels, albums.music_brainz_id, albums.release_types, albums.is_compilation, albums.replay_gain, albums.replay_gain_peak, COALESCE(tracks.count, 0) AS track_count, COALESCE(tracks.duration_ms, 0) AS duration_ms, album_stars.created as starred, album_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM albums
LEFT JOIN (
  SELECT album_id, COUNT(*) AS count, SUM(duration_ms) AS duration_ms FROM songs GROUP BY album_id
) tracks ON tracks.album_id = albums.id
LEFT JOIN album_stars ON album_stars.album_id = albums.id AND album_stars.user_name = $1
LEFT JOIN (
  SELECT album_id, AVG(album_ratings.rating) AS rating FROM album_ratings GROUP BY album_id
) avgr ON avgr.album_id = albums.id
LEFT JOIN album_ratings ON album_ratings.album_id = albums.id AND album_ratings.user_name = $1
WHERE albums.id = $2
`

type FindAlbumParams struct {
	UserName string
	ID       string
}

type FindAlbumRow struct {
	ID             string
	Name           string
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Year           *int32
	RecordLabels   *string
	MusicBrainzID  *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
	TrackCount     int64
	DurationMs     int64
	Starred        pgtype.Timestamptz
	UserRating     *int32
	AvgRating      float64
}

func (q *Queries) FindAlbum(ctx context.Context, arg FindAlbumParams) (*FindAlbumRow, error) {
	row := q.db.QueryRow(ctx, findAlbum, arg.UserName, arg.ID)
	var i FindAlbumRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Created,
		&i.Updated,
		&i.Year,
		&i.RecordLabels,
		&i.MusicBrainzID,
		&i.ReleaseTypes,
		&i.IsCompilation,
		&i.ReplayGain,
		&i.ReplayGainPeak,
		&i.TrackCount,
		&i.DurationMs,
		&i.Starred,
		&i.UserRating,
		&i.AvgRating,
	)
	return &i, err
}

const findAlbumsAlphabeticalByName = `-- name: FindAlbumsAlphabeticalByName :many
SELECT albums.id, albums.name, albums.created, albums.updated, albums.year, albums.record_labels, albums.music_brainz_id, albums.release_types, albums.is_compilation, albums.replay_gain, albums.replay_gain_peak, COALESCE(tracks.count, 0) AS track_count, COALESCE(tracks.duration_ms, 0) AS duration_ms, album_stars.created as starred, album_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM albums
LEFT JOIN (
  SELECT album_id, COUNT(*) AS count, SUM(duration_ms) AS duration_ms FROM songs GROUP BY album_id
) tracks ON tracks.album_id = albums.id
LEFT JOIN album_stars ON album_stars.album_id = albums.id AND album_stars.user_name = $1
LEFT JOIN (
  SELECT album_id, AVG(album_ratings.rating) AS rating FROM album_ratings GROUP BY album_id
) avgr ON avgr.album_id = albums.id
LEFT JOIN album_ratings ON album_ratings.album_id = albums.id AND album_ratings.user_name = $1
WHERE (cast($4 as int) IS NULL OR (albums.year IS NOT NULL AND albums.year >= $4))
AND (cast($5 as int) IS NULL OR (albums.year IS NOT NULL AND albums.year <= $5))
AND ($6::text[] IS NULL OR EXISTS (
  SELECT album_genre.album_id, genres.name FROM album_genre
  JOIN genres ON album_genre.genre_name = genres.name
  WHERE album_genre.album_id = albums.id AND lower(album_genre.genre_name) = any($6::text[])
))
ORDER BY lower(albums.name)
OFFSET $2 LIMIT $3
`

type FindAlbumsAlphabeticalByNameParams struct {
	UserName    string
	Offset      int32
	Limit       int32
	FromYear    *int32
	ToYear      *int32
	GenresLower []string
}

type FindAlbumsAlphabeticalByNameRow struct {
	ID             string
	Name           string
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Year           *int32
	RecordLabels   *string
	MusicBrainzID  *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
	TrackCount     int64
	DurationMs     int64
	Starred        pgtype.Timestamptz
	UserRating     *int32
	AvgRating      float64
}

func (q *Queries) FindAlbumsAlphabeticalByName(ctx context.Context, arg FindAlbumsAlphabeticalByNameParams) ([]*FindAlbumsAlphabeticalByNameRow, error) {
	rows, err := q.db.Query(ctx, findAlbumsAlphabeticalByName,
		arg.UserName,
		arg.Offset,
		arg.Limit,
		arg.FromYear,
		arg.ToYear,
		arg.GenresLower,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAlbumsAlphabeticalByNameRow
	for rows.Next() {
		var i FindAlbumsAlphabeticalByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Updated,
			&i.Year,
			&i.RecordLabels,
			&i.MusicBrainzID,
			&i.ReleaseTypes,
			&i.IsCompilation,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.TrackCount,
			&i.DurationMs,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAlbumsByArtist = `-- name: FindAlbumsByArtist :many
SELECT albums.id, albums.name, albums.created, albums.updated, albums.year, albums.record_labels, albums.music_brainz_id, albums.release_types, albums.is_compilation, albums.replay_gain, albums.replay_gain_peak, COALESCE(tracks.count, 0) AS track_count, COALESCE(tracks.duration_ms, 0) AS duration_ms, album_stars.created as starred, album_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM albums
LEFT JOIN (
  SELECT album_id, COUNT(*) AS count, SUM(duration_ms) AS duration_ms FROM songs GROUP BY album_id
) tracks ON tracks.album_id = albums.id
LEFT JOIN album_stars ON album_stars.album_id = albums.id AND album_stars.user_name = $1
LEFT JOIN (
  SELECT album_id, AVG(album_ratings.rating) AS rating FROM album_ratings GROUP BY album_id
) avgr ON avgr.album_id = albums.id
LEFT JOIN album_ratings ON album_ratings.album_id = albums.id AND album_ratings.user_name = $1
WHERE EXISTS (
  SELECT album_artist.album_id, album_artist.artist_id FROM album_artist
  WHERE album_artist.album_id = albums.id AND album_artist.artist_id = $2
)
`

type FindAlbumsByArtistParams struct {
	UserName string
	ArtistID string
}

type FindAlbumsByArtistRow struct {
	ID             string
	Name           string
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Year           *int32
	RecordLabels   *string
	MusicBrainzID  *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
	TrackCount     int64
	DurationMs     int64
	Starred        pgtype.Timestamptz
	UserRating     *int32
	AvgRating      float64
}

func (q *Queries) FindAlbumsByArtist(ctx context.Context, arg FindAlbumsByArtistParams) ([]*FindAlbumsByArtistRow, error) {
	rows, err := q.db.Query(ctx, findAlbumsByArtist, arg.UserName, arg.ArtistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAlbumsByArtistRow
	for rows.Next() {
		var i FindAlbumsByArtistRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Updated,
			&i.Year,
			&i.RecordLabels,
			&i.MusicBrainzID,
			&i.ReleaseTypes,
			&i.IsCompilation,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.TrackCount,
			&i.DurationMs,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAlbumsByGenre = `-- name: FindAlbumsByGenre :many
SELECT albums.id, albums.name, albums.created, albums.updated, albums.year, albums.record_labels, albums.music_brainz_id, albums.release_types, albums.is_compilation, albums.replay_gain, albums.replay_gain_peak, COALESCE(tracks.count, 0) AS track_count, COALESCE(tracks.duration_ms, 0) AS duration_ms, album_stars.created as starred, album_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM albums
LEFT JOIN (
  SELECT album_id, COUNT(*) AS count, SUM(duration_ms) AS duration_ms FROM songs GROUP BY album_id
) tracks ON tracks.album_id = albums.id
LEFT JOIN album_stars ON album_stars.album_id = albums.id AND album_stars.user_name = $1
LEFT JOIN (
  SELECT album_id, AVG(album_ratings.rating) AS rating FROM album_ratings GROUP BY album_id
) avgr ON avgr.album_id = albums.id
LEFT JOIN album_ratings ON album_ratings.album_id = albums.id AND album_ratings.user_name = $1
WHERE (cast($4 as int) IS NULL OR albums.year >= $4)
AND (cast($5 as int) IS NULL OR albums.year <= $5)
AND EXISTS (
  SELECT album_genre.album_id, genres.name FROM album_genre
  JOIN genres ON album_genre.genre_name = genres.name
  WHERE album_genre.album_id = albums.id AND lower(album_genre.genre_name) = any($6::text[])
)
ORDER BY lower(albums.name)
OFFSET $2 LIMIT $3
`

type FindAlbumsByGenreParams struct {
	UserName    string
	Offset      int32
	Limit       int32
	FromYear    *int32
	ToYear      *int32
	GenresLower []string
}

type FindAlbumsByGenreRow struct {
	ID             string
	Name           string
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Year           *int32
	RecordLabels   *string
	MusicBrainzID  *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
	TrackCount     int64
	DurationMs     int64
	Starred        pgtype.Timestamptz
	UserRating     *int32
	AvgRating      float64
}

func (q *Queries) FindAlbumsByGenre(ctx context.Context, arg FindAlbumsByGenreParams) ([]*FindAlbumsByGenreRow, error) {
	rows, err := q.db.Query(ctx, findAlbumsByGenre,
		arg.UserName,
		arg.Offset,
		arg.Limit,
		arg.FromYear,
		arg.ToYear,
		arg.GenresLower,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAlbumsByGenreRow
	for rows.Next() {
		var i FindAlbumsByGenreRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Updated,
			&i.Year,
			&i.RecordLabels,
			&i.MusicBrainzID,
			&i.ReleaseTypes,
			&i.IsCompilation,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.TrackCount,
			&i.DurationMs,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAlbumsByNameWithArtistMatchCount = `-- name: FindAlbumsByNameWithArtistMatchCount :many
SELECT albums.id, albums.music_brainz_id, COUNT(artists.id) AS artist_matches FROM albums
LEFT JOIN album_artist ON albums.id = album_artist.album_id
LEFT JOIN artists ON album_artist.artist_id = artists.id AND artists.name = any($2::text[])
WHERE albums.name = $1
GROUP BY albums.id, albums.music_brainz_id
`

type FindAlbumsByNameWithArtistMatchCountParams struct {
	Name        string
	ArtistNames []string
}

type FindAlbumsByNameWithArtistMatchCountRow struct {
	ID            string
	MusicBrainzID *string
	ArtistMatches int64
}

func (q *Queries) FindAlbumsByNameWithArtistMatchCount(ctx context.Context, arg FindAlbumsByNameWithArtistMatchCountParams) ([]*FindAlbumsByNameWithArtistMatchCountRow, error) {
	rows, err := q.db.Query(ctx, findAlbumsByNameWithArtistMatchCount, arg.Name, arg.ArtistNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAlbumsByNameWithArtistMatchCountRow
	for rows.Next() {
		var i FindAlbumsByNameWithArtistMatchCountRow
		if err := rows.Scan(&i.ID, &i.MusicBrainzID, &i.ArtistMatches); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAlbumsByYear = `-- name: FindAlbumsByYear :many
SELECT albums.id, albums.name, albums.created, albums.updated, albums.year, albums.record_labels, albums.music_brainz_id, albums.release_types, albums.is_compilation, albums.replay_gain, albums.replay_gain_peak, COALESCE(tracks.count, 0) AS track_count, COALESCE(tracks.duration_ms, 0) AS duration_ms, album_stars.created as starred, album_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM albums
LEFT JOIN (
  SELECT album_id, COUNT(*) AS count, SUM(duration_ms) AS duration_ms FROM songs GROUP BY album_id
) tracks ON tracks.album_id = albums.id
LEFT JOIN album_stars ON album_stars.album_id = albums.id AND album_stars.user_name = $1
LEFT JOIN (
  SELECT album_id, AVG(album_ratings.rating) AS rating FROM album_ratings GROUP BY album_id
) avgr ON avgr.album_id = albums.id
LEFT JOIN album_ratings ON album_ratings.album_id = albums.id AND album_ratings.user_name = $1
WHERE albums.year IS NOT NULL
AND albums.year >= $4
AND albums.year <= $5
AND ($6::text[] IS NULL OR EXISTS (
  SELECT album_genre.album_id, genres.name FROM album_genre
  JOIN genres ON album_genre.genre_name = genres.name
  WHERE album_genre.album_id = albums.id AND lower(album_genre.genre_name) = any($6::text[])
))
ORDER BY albums.year, lower(albums.name)
OFFSET $2 LIMIT $3
`

type FindAlbumsByYearParams struct {
	UserName    string
	Offset      int32
	Limit       int32
	FromYear    *int32
	ToYear      *int32
	GenresLower []string
}

type FindAlbumsByYearRow struct {
	ID             string
	Name           string
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Year           *int32
	RecordLabels   *string
	MusicBrainzID  *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
	TrackCount     int64
	DurationMs     int64
	Starred        pgtype.Timestamptz
	UserRating     *int32
	AvgRating      float64
}

func (q *Queries) FindAlbumsByYear(ctx context.Context, arg FindAlbumsByYearParams) ([]*FindAlbumsByYearRow, error) {
	rows, err := q.db.Query(ctx, findAlbumsByYear,
		arg.UserName,
		arg.Offset,
		arg.Limit,
		arg.FromYear,
		arg.ToYear,
		arg.GenresLower,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAlbumsByYearRow
	for rows.Next() {
		var i FindAlbumsByYearRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Updated,
			&i.Year,
			&i.RecordLabels,
			&i.MusicBrainzID,
			&i.ReleaseTypes,
			&i.IsCompilation,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.TrackCount,
			&i.DurationMs,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAlbumsHighestRated = `-- name: FindAlbumsHighestRated :many
SELECT albums.id, albums.name, albums.created, albums.updated, albums.year, albums.record_labels, albums.music_brainz_id, albums.release_types, albums.is_compilation, albums.replay_gain, albums.replay_gain_peak, COALESCE(tracks.count, 0) AS track_count, COALESCE(tracks.duration_ms, 0) AS duration_ms, album_stars.created as starred, album_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM albums
LEFT JOIN (
  SELECT album_id, COUNT(*) AS count, SUM(duration_ms) AS duration_ms FROM songs GROUP BY album_id
) tracks ON tracks.album_id = albums.id
LEFT JOIN album_stars ON album_stars.album_id = albums.id AND album_stars.user_name = $1
LEFT JOIN (
  SELECT album_id, AVG(album_ratings.rating) AS rating FROM album_ratings GROUP BY album_id
) avgr ON avgr.album_id = albums.id
LEFT JOIN album_ratings ON album_ratings.album_id = albums.id AND album_ratings.user_name = $1
WHERE (cast($4 as int) IS NULL OR (albums.year IS NOT NULL AND albums.year >= $4))
AND (cast($5 as int) IS NULL OR (albums.year IS NOT NULL AND albums.year <= $5))
AND ($6::text[] IS NULL OR EXISTS (
  SELECT album_genre.album_id, genres.name FROM album_genre
  JOIN genres ON album_genre.genre_name = genres.name
  WHERE album_genre.album_id = albums.id AND lower(album_genre.genre_name) = any($6::text[])
))
ORDER BY COALESCE(album_ratings.rating, 0) DESC, lower(albums.name)
OFFSET $2 LIMIT $3
`

type FindAlbumsHighestRatedParams struct {
	UserName    string
	Offset      int32
	Limit       int32
	FromYear    *int32
	ToYear      *int32
	GenresLower []string
}

type FindAlbumsHighestRatedRow struct {
	ID             string
	Name           string
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Year           *int32
	RecordLabels   *string
	MusicBrainzID  *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
	TrackCount     int64
	DurationMs     int64
	Starred        pgtype.Timestamptz
	UserRating     *int32
	AvgRating      float64
}

func (q *Queries) FindAlbumsHighestRated(ctx context.Context, arg FindAlbumsHighestRatedParams) ([]*FindAlbumsHighestRatedRow, error) {
	rows, err := q.db.Query(ctx, findAlbumsHighestRated,
		arg.UserName,
		arg.Offset,
		arg.Limit,
		arg.FromYear,
		arg.ToYear,
		arg.GenresLower,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAlbumsHighestRatedRow
	for rows.Next() {
		var i FindAlbumsHighestRatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Updated,
			&i.Year,
			&i.RecordLabels,
			&i.MusicBrainzID,
			&i.ReleaseTypes,
			&i.IsCompilation,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.TrackCount,
			&i.DurationMs,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAlbumsNewest = `-- name: FindAlbumsNewest :many
SELECT albums.id, albums.name, albums.created, albums.updated, albums.year, albums.record_labels, albums.music_brainz_id, albums.release_types, albums.is_compilation, albums.replay_gain, albums.replay_gain_peak, COALESCE(tracks.count, 0) AS track_count, COALESCE(tracks.duration_ms, 0) AS duration_ms, album_stars.created as starred, album_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM albums
LEFT JOIN (
  SELECT album_id, COUNT(*) AS count, SUM(duration_ms) AS duration_ms FROM songs GROUP BY album_id
) tracks ON tracks.album_id = albums.id
LEFT JOIN album_stars ON album_stars.album_id = albums.id AND album_stars.user_name = $1
LEFT JOIN (
  SELECT album_id, AVG(album_ratings.rating) AS rating FROM album_ratings GROUP BY album_id
) avgr ON avgr.album_id = albums.id
LEFT JOIN album_ratings ON album_ratings.album_id = albums.id AND album_ratings.user_name = $1
WHERE (cast($4 as int) IS NULL OR (albums.year IS NOT NULL AND albums.year >= $4))
AND (cast($5 as int) IS NULL OR (albums.year IS NOT NULL AND albums.year <= $5))
AND ($6::text[] IS NULL OR EXISTS (
  SELECT album_genre.album_id, genres.name FROM album_genre
  JOIN genres ON album_genre.genre_name = genres.name
  WHERE album_genre.album_id = albums.id AND lower(album_genre.genre_name) = any($6::text[])
))
ORDER BY albums.created DESC, lower(albums.name)
OFFSET $2 LIMIT $3
`

type FindAlbumsNewestParams struct {
	UserName    string
	Offset      int32
	Limit       int32
	FromYear    *int32
	ToYear      *int32
	GenresLower []string
}

type FindAlbumsNewestRow struct {
	ID             string
	Name           string
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Year           *int32
	RecordLabels   *string
	MusicBrainzID  *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
	TrackCount     int64
	DurationMs     int64
	Starred        pgtype.Timestamptz
	UserRating     *int32
	AvgRating      float64
}

func (q *Queries) FindAlbumsNewest(ctx context.Context, arg FindAlbumsNewestParams) ([]*FindAlbumsNewestRow, error) {
	rows, err := q.db.Query(ctx, findAlbumsNewest,
		arg.UserName,
		arg.Offset,
		arg.Limit,
		arg.FromYear,
		arg.ToYear,
		arg.GenresLower,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAlbumsNewestRow
	for rows.Next() {
		var i FindAlbumsNewestRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Updated,
			&i.Year,
			&i.RecordLabels,
			&i.MusicBrainzID,
			&i.ReleaseTypes,
			&i.IsCompilation,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.TrackCount,
			&i.DurationMs,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAlbumsRandom = `-- name: FindAlbumsRandom :many
SELECT albums.id, albums.name, albums.created, albums.updated, albums.year, albums.record_labels, albums.music_brainz_id, albums.release_types, albums.is_compilation, albums.replay_gain, albums.replay_gain_peak, COALESCE(tracks.count, 0) AS track_count, COALESCE(tracks.duration_ms, 0) AS duration_ms, album_stars.created as starred, album_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM albums
LEFT JOIN (
  SELECT album_id, COUNT(*) AS count, SUM(duration_ms) AS duration_ms FROM songs GROUP BY album_id
) tracks ON tracks.album_id = albums.id
LEFT JOIN album_stars ON album_stars.album_id = albums.id AND album_stars.user_name = $1
LEFT JOIN (
  SELECT album_id, AVG(album_ratings.rating) AS rating FROM album_ratings GROUP BY album_id
) avgr ON avgr.album_id = albums.id
LEFT JOIN album_ratings ON album_ratings.album_id = albums.id AND album_ratings.user_name = $1
WHERE (cast($3 as int) IS NULL OR (albums.year IS NOT NULL AND albums.year >= $3))
AND (cast($4 as int) IS NULL OR (albums.year IS NOT NULL AND albums.year <= $4))
AND ($5::text[] IS NULL OR EXISTS (
  SELECT album_genre.album_id, genres.name FROM album_genre
  JOIN genres ON album_genre.genre_name = genres.name
  WHERE album_genre.album_id = albums.id AND lower(album_genre.genre_name) = any($5::text[])
))
ORDER BY random()
LIMIT $2
`

type FindAlbumsRandomParams struct {
	UserName    string
	Limit       int32
	FromYear    *int32
	ToYear      *int32
	GenresLower []string
}

type FindAlbumsRandomRow struct {
	ID             string
	Name           string
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Year           *int32
	RecordLabels   *string
	MusicBrainzID  *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
	TrackCount     int64
	DurationMs     int64
	Starred        pgtype.Timestamptz
	UserRating     *int32
	AvgRating      float64
}

func (q *Queries) FindAlbumsRandom(ctx context.Context, arg FindAlbumsRandomParams) ([]*FindAlbumsRandomRow, error) {
	rows, err := q.db.Query(ctx, findAlbumsRandom,
		arg.UserName,
		arg.Limit,
		arg.FromYear,
		arg.ToYear,
		arg.GenresLower,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAlbumsRandomRow
	for rows.Next() {
		var i FindAlbumsRandomRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Updated,
			&i.Year,
			&i.RecordLabels,
			&i.MusicBrainzID,
			&i.ReleaseTypes,
			&i.IsCompilation,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.TrackCount,
			&i.DurationMs,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAlbumsStarred = `-- name: FindAlbumsStarred :many
SELECT albums.id, albums.name, albums.created, albums.updated, albums.year, albums.record_labels, albums.music_brainz_id, albums.release_types, albums.is_compilation, albums.replay_gain, albums.replay_gain_peak, COALESCE(tracks.count, 0) AS track_count, COALESCE(tracks.duration_ms, 0) AS duration_ms, album_stars.created as starred, album_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM albums
LEFT JOIN (
  SELECT album_id, COUNT(*) AS count, SUM(duration_ms) AS duration_ms FROM songs GROUP BY album_id
) tracks ON tracks.album_id = albums.id
LEFT JOIN album_stars ON album_stars.album_id = albums.id AND album_stars.user_name = $1
LEFT JOIN (
  SELECT album_id, AVG(album_ratings.rating) AS rating FROM album_ratings GROUP BY album_id
) avgr ON avgr.album_id = albums.id
LEFT JOIN album_ratings ON album_ratings.album_id = albums.id AND album_ratings.user_name = $1
WHERE album_stars.created IS NOT NULL
AND (cast($4 as int) IS NULL OR (albums.year IS NOT NULL AND albums.year >= $4))
AND (cast($5 as int) IS NULL OR (albums.year IS NOT NULL AND albums.year <= $5))
AND ($6::text[] IS NULL OR EXISTS (
  SELECT album_genre.album_id, genres.name FROM album_genre
  JOIN genres ON album_genre.genre_name = genres.name
  WHERE album_genre.album_id = albums.id AND lower(album_genre.genre_name) = any($6::text[])
))
ORDER BY album_stars.created DESC, lower(albums.name)
OFFSET $2 LIMIT $3
`

type FindAlbumsStarredParams struct {
	UserName    string
	Offset      int32
	Limit       int32
	FromYear    *int32
	ToYear      *int32
	GenresLower []string
}

type FindAlbumsStarredRow struct {
	ID             string
	Name           string
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Year           *int32
	RecordLabels   *string
	MusicBrainzID  *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
	TrackCount     int64
	DurationMs     int64
	Starred        pgtype.Timestamptz
	UserRating     *int32
	AvgRating      float64
}

func (q *Queries) FindAlbumsStarred(ctx context.Context, arg FindAlbumsStarredParams) ([]*FindAlbumsStarredRow, error) {
	rows, err := q.db.Query(ctx, findAlbumsStarred,
		arg.UserName,
		arg.Offset,
		arg.Limit,
		arg.FromYear,
		arg.ToYear,
		arg.GenresLower,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAlbumsStarredRow
	for rows.Next() {
		var i FindAlbumsStarredRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Updated,
			&i.Year,
			&i.RecordLabels,
			&i.MusicBrainzID,
			&i.ReleaseTypes,
			&i.IsCompilation,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.TrackCount,
			&i.DurationMs,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAlbums = `-- name: SearchAlbums :many
SELECT albums.id, albums.name, albums.created, albums.updated, albums.year, albums.record_labels, albums.music_brainz_id, albums.release_types, albums.is_compilation, albums.replay_gain, albums.replay_gain_peak, COALESCE(tracks.count, 0) AS track_count, COALESCE(tracks.duration_ms, 0) AS duration_ms, album_stars.created as starred, album_ratings.rating AS user_rating, COALESCE(avgr.rating, 0) AS avg_rating FROM albums
LEFT JOIN (
  SELECT album_id, COUNT(*) AS count, SUM(duration_ms) AS duration_ms FROM songs GROUP BY album_id
) tracks ON tracks.album_id = albums.id
LEFT JOIN album_stars ON album_stars.album_id = albums.id AND album_stars.user_name = $1
LEFT JOIN (
  SELECT album_id, AVG(album_ratings.rating) AS rating FROM album_ratings GROUP BY album_id
) avgr ON avgr.album_id = albums.id
LEFT JOIN album_ratings ON album_ratings.album_id = albums.id AND album_ratings.user_name = $1
WHERE position(lower($4) in lower(albums.name)) > 0
ORDER BY position(lower($4) in lower(albums.name)), lower(albums.name)
OFFSET $2 LIMIT $3
`

type SearchAlbumsParams struct {
	UserName  string
	Offset    int32
	Limit     int32
	SearchStr string
}

type SearchAlbumsRow struct {
	ID             string
	Name           string
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	Year           *int32
	RecordLabels   *string
	MusicBrainzID  *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
	TrackCount     int64
	DurationMs     int64
	Starred        pgtype.Timestamptz
	UserRating     *int32
	AvgRating      float64
}

func (q *Queries) SearchAlbums(ctx context.Context, arg SearchAlbumsParams) ([]*SearchAlbumsRow, error) {
	rows, err := q.db.Query(ctx, searchAlbums,
		arg.UserName,
		arg.Offset,
		arg.Limit,
		arg.SearchStr,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchAlbumsRow
	for rows.Next() {
		var i SearchAlbumsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Updated,
			&i.Year,
			&i.RecordLabels,
			&i.MusicBrainzID,
			&i.ReleaseTypes,
			&i.IsCompilation,
			&i.ReplayGain,
			&i.ReplayGainPeak,
			&i.TrackCount,
			&i.DurationMs,
			&i.Starred,
			&i.UserRating,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAlbum = `-- name: UpdateAlbum :exec
UPDATE albums
SET name = $2, year = $3, record_labels = $4, release_types = $5, is_compilation = $6, replay_gain = $7, replay_gain_peak = $8, updated = NOW()
WHERE id = $1
`

type UpdateAlbumParams struct {
	ID             string
	Name           string
	Year           *int32
	RecordLabels   *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
}

func (q *Queries) UpdateAlbum(ctx context.Context, arg UpdateAlbumParams) error {
	_, err := q.db.Exec(ctx, updateAlbum,
		arg.ID,
		arg.Name,
		arg.Year,
		arg.RecordLabels,
		arg.ReleaseTypes,
		arg.IsCompilation,
		arg.ReplayGain,
		arg.ReplayGainPeak,
	)
	return err
}
