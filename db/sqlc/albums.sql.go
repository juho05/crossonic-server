// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: albums.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAlbum = `-- name: CreateAlbum :one
INSERT INTO albums
(id, name, created, updated, year, record_labels, music_brainz_id, release_types, is_compilation, replay_gain, replay_gain_peak)
VALUES($1, $2, NOW(), NOW(), $3, $4, $5, $6, $7, $8, $9)
RETURNING id, name, created, updated, year, record_labels, music_brainz_id, release_types, is_compilation, replay_gain, replay_gain_peak
`

type CreateAlbumParams struct {
	ID             string
	Name           string
	Year           *int32
	RecordLabels   *string
	MusicBrainzID  *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
}

func (q *Queries) CreateAlbum(ctx context.Context, arg CreateAlbumParams) (*Album, error) {
	row := q.db.QueryRow(ctx, createAlbum,
		arg.ID,
		arg.Name,
		arg.Year,
		arg.RecordLabels,
		arg.MusicBrainzID,
		arg.ReleaseTypes,
		arg.IsCompilation,
		arg.ReplayGain,
		arg.ReplayGainPeak,
	)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Created,
		&i.Updated,
		&i.Year,
		&i.RecordLabels,
		&i.MusicBrainzID,
		&i.ReleaseTypes,
		&i.IsCompilation,
		&i.ReplayGain,
		&i.ReplayGainPeak,
	)
	return &i, err
}

type CreateAlbumArtistsParams struct {
	AlbumID  string
	ArtistID string
}

type CreateAlbumGenresParams struct {
	AlbumID   string
	GenreName string
}

const deleteAlbumArtists = `-- name: DeleteAlbumArtists :exec
DELETE FROM album_artist WHERE album_id = $1
`

func (q *Queries) DeleteAlbumArtists(ctx context.Context, albumID string) error {
	_, err := q.db.Exec(ctx, deleteAlbumArtists, albumID)
	return err
}

const deleteAlbumGenres = `-- name: DeleteAlbumGenres :exec
DELETE FROM album_genre WHERE album_id = $1
`

func (q *Queries) DeleteAlbumGenres(ctx context.Context, albumID string) error {
	_, err := q.db.Exec(ctx, deleteAlbumGenres, albumID)
	return err
}

const deleteAlbumsLastUpdatedBefore = `-- name: DeleteAlbumsLastUpdatedBefore :exec
DELETE FROM albums WHERE updated < $1
`

func (q *Queries) DeleteAlbumsLastUpdatedBefore(ctx context.Context, updated pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteAlbumsLastUpdatedBefore, updated)
	return err
}

const findAlbumsByNameWithArtistMatchCount = `-- name: FindAlbumsByNameWithArtistMatchCount :many
SELECT albums.id, albums.music_brainz_id, COUNT(artists.id) AS artist_matches FROM albums
LEFT JOIN album_artist ON albums.id = album_artist.album_id
LEFT JOIN artists ON album_artist.artist_id = artists.id AND artists.name = any($2::text[])
WHERE albums.name = $1
GROUP BY albums.id, albums.music_brainz_id
`

type FindAlbumsByNameWithArtistMatchCountParams struct {
	Name        string
	ArtistNames []string
}

type FindAlbumsByNameWithArtistMatchCountRow struct {
	ID            string
	MusicBrainzID *string
	ArtistMatches int64
}

func (q *Queries) FindAlbumsByNameWithArtistMatchCount(ctx context.Context, arg FindAlbumsByNameWithArtistMatchCountParams) ([]*FindAlbumsByNameWithArtistMatchCountRow, error) {
	rows, err := q.db.Query(ctx, findAlbumsByNameWithArtistMatchCount, arg.Name, arg.ArtistNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindAlbumsByNameWithArtistMatchCountRow
	for rows.Next() {
		var i FindAlbumsByNameWithArtistMatchCountRow
		if err := rows.Scan(&i.ID, &i.MusicBrainzID, &i.ArtistMatches); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAlbum = `-- name: UpdateAlbum :exec
UPDATE albums
SET name = $2, year = $3, record_labels = $4, release_types = $5, is_compilation = $6, replay_gain = $7, replay_gain_peak = $8, updated = NOW()
WHERE id = $1
`

type UpdateAlbumParams struct {
	ID             string
	Name           string
	Year           *int32
	RecordLabels   *string
	ReleaseTypes   *string
	IsCompilation  *bool
	ReplayGain     *float32
	ReplayGainPeak *float32
}

func (q *Queries) UpdateAlbum(ctx context.Context, arg UpdateAlbumParams) error {
	_, err := q.db.Exec(ctx, updateAlbum,
		arg.ID,
		arg.Name,
		arg.Year,
		arg.RecordLabels,
		arg.ReleaseTypes,
		arg.IsCompilation,
		arg.ReplayGain,
		arg.ReplayGainPeak,
	)
	return err
}
